"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var changeElementTag_1 = require("../utils/changeElementTag");
var getListTypeFromNode_1 = require("./getListTypeFromNode");
var getTagOfNode_1 = require("../utils/getTagOfNode");
var isBlockElement_1 = require("../utils/isBlockElement");
var isNodeEmpty_1 = require("../utils/isNodeEmpty");
var Position_1 = require("../selection/Position");
var queryElements_1 = require("../utils/queryElements");
var safeInstanceOf_1 = require("../utils/safeInstanceOf");
var splitParentNode_1 = require("../utils/splitParentNode");
var toArray_1 = require("../utils/toArray");
var unwrap_1 = require("../utils/unwrap");
var VListItem_1 = require("./VListItem");
var wrap_1 = require("../utils/wrap");
/**
 * Represent a bullet or a numbering list
 *
 * @example
 * A VList is a logical representation of list items, it contains an item array with node and list type stack.
 * e.g. We have a list like this
 * ```html
 * <ol>
 *   <li>item 1</li>
 *   <li>item 2</li>
 *   <ul>
 *     <li>item 2.1</li>
 *     <li>item 2.2</li>
 *   <ul>
 * </ol>
 * ```
 *
 * A VList of this list will be like this:
 * ```javascript
 * {
 *   rootList: (OL node),
 *   items: [{
 *       node: (LI node with 'item 1'),
 *       listTypes: [null, OL],
 *     }, {
 *       node: (LI node with 'item 2'),
 *       listTypes: [null, OL],
 *     }, {
 *       node: (LI node with 'item 2.1),
 *       listTypes: [null, OL, UL],
 *     }, {
 *       node: (LI node with 'item 2.2'),
 *       listTypes: [null, OL, UL],
 *     }
 *   ]
 * }
 * ```
 *
 * When we want to outdent item 2.1, we just need to remove the last "UL" from listTypes of item 2.1, then
 * the writeBack() function will handle everything related to DOM change
 */
var VList = /** @class */ (function () {
    /**
     * Create a new instance of VList class
     * @param rootList The root list element, can be either OL or UL tag
     */
    function VList(rootList) {
        this.rootList = rootList;
        this.items = [];
        if (!rootList) {
            throw new Error('rootList must not be null');
        }
        // Before populate items, we need to normalize the list to make sure it is in a correct format
        // otherwise further action may mass thing up.
        //
        // There are two kinds of normalization to perform.
        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node
        // Please see comment for VListItem.isOrphanItem() for more information about orphan node
        // e.g.:
        // ```HTML
        // <ol>
        //   <li>item 1</li>
        //   <div>item 2</div>
        // </ol>
        // ```
        // After this step, it should become:
        // ```html
        // <ol>
        //   <li>item 1
        //     <div>item 2</div>
        //   <li>
        // </ol>
        // ```
        moveChildNodesToLi(this.rootList);
        (0, queryElements_1.default)(this.rootList, 'ol,ul', moveChildNodesToLi);
        // 2. Move LI node embedded into another LI node out to directly under OL/UL node
        // Ideally browser we do this for us automatically when out the HTML into DOM. However after
        // step 1, it is possible that we move some LI node into another one. e.g:
        // ```HTML
        // <ol>
        //   <li>item 1</li>
        //   <div>
        //     item 1.1
        //     <li>item 3</li>
        //   </div>
        // </ol>
        // ```
        // See that the second LI tag is not directly under OL, so after step 1, this will become:
        // ```html
        // <ol>
        //   <li>item 1
        //     <div>
        //       item 1.1
        //       <li>item 2</li>
        //     </div>
        //   <li>
        // </ol>
        // ```
        // Now we have a LI tag embedded into another LI tag. So we need step 2 to move the inner LI tag out to be:
        // ```html
        // <ol>
        //   <li>item1
        //     <div>item 1.1</div>
        //   </li>
        //   <li><div>item2</div></li>
        // </ol>
        // ```
        (0, queryElements_1.default)(this.rootList, 'li', moveLiToList);
        this.populateItems(this.rootList);
    }
    /**
     * Check if this list contains the given node
     * @param node The node to check
     */
    VList.prototype.contains = function (node) {
        // We don't check if the node is contained by this.rootList here, because after some operation,
        // it is possible a node is logically contained by this list but the container list item hasn't
        // been put under this.rootList in DOM tree yet.
        return this.items.some(function (item) { return item.contains(node); });
    };
    /**
     * Get list number of the last item in this VList.
     * If there is no order list item, result will be undefined
     */
    VList.prototype.getLastItemNumber = function () {
        var start = getStart(this.rootList);
        return start === undefined
            ? start
            : start -
                1 +
                this.items.filter(function (item) {
                    return item.getListType() == 1 /* Ordered */ &&
                        item.getLevel() == 1 &&
                        !item.isDummy();
                }).length;
    };
    /**
     * Write the result back into DOM tree
     * After that, this VList becomes unavailable because we set this.rootList to null
     */
    VList.prototype.writeBack = function () {
        var _this = this;
        if (!this.rootList) {
            throw new Error('rootList must not be null');
        }
        var doc = this.rootList.ownerDocument;
        var listStack = [doc.createDocumentFragment()];
        var placeholder = doc.createTextNode('');
        var start = getStart(this.rootList) || 1;
        var lastList;
        // Use a placeholder to hold the position since the root list may be moved into document fragment later
        this.rootList.parentNode.replaceChild(placeholder, this.rootList);
        this.items.forEach(function (item) {
            if (item.getNewListStart() && item.getNewListStart() != start) {
                listStack.splice(1, listStack.length - 1);
                start = item.getNewListStart();
            }
            item.writeBack(listStack, _this.rootList);
            var topList = listStack[1];
            if ((0, safeInstanceOf_1.default)(topList, 'HTMLOListElement')) {
                if (lastList != topList) {
                    if (start == 1) {
                        topList.removeAttribute('start');
                    }
                    else {
                        topList.start = start;
                    }
                }
                if (item.getLevel() == 1) {
                    start++;
                }
            }
            lastList = topList;
        });
        // Restore the content to the position of placeholder
        placeholder.parentNode.replaceChild(listStack[0], placeholder);
        // Set rootList to null to avoid this to be called again for the same VList, because
        // after change the rootList may not be available any more (e.g. outdent all items).
        this.rootList = null;
    };
    /**
     * Sets the New List Start Property, that is going to be used to create a new List in the WriteBack function
     * @param separator The HTML element that indicates when to split the VList
     * @param startNumber The start number of the new List
     */
    VList.prototype.split = function (separator, startNumber) {
        if (!this.rootList) {
            throw new Error('rootList must not be null');
        }
        //Traverse the items of the VList, when the separator is found, set the New List Start Property
        for (var index = 0; index < this.items.length; index++) {
            if (this.items[index].getNode() == separator) {
                this.items[index].setNewListStart(startNumber);
                return;
            }
        }
    };
    VList.prototype.setIndentation = function (start, end, indentation, softOutdent) {
        this.findListItems(start, end, function (item) {
            return indentation == 1 /* Decrease */
                ? softOutdent && !item.isDummy()
                    ? item.setIsDummy(true /*isDummy*/)
                    : item.outdent()
                : item.indent();
        });
    };
    /**
     * Change list type of the given range of this list.
     * If some of the items are not real list item yet, this will make them to be list item with given type
     * If all items in the given range are already in the type to change to, this becomes an outdent operation
     * @param start Start position to operate from
     * @param end End position to operate to
     * @param targetType Target list type
     */
    VList.prototype.changeListType = function (start, end, targetType) {
        var needChangeType = false;
        this.findListItems(start, end, function (item) {
            needChangeType = needChangeType || item.getListType() != targetType;
        });
        this.findListItems(start, end, function (item) {
            return needChangeType ? item.changeListType(targetType) : item.outdent();
        });
    };
    /**
     * Append a new item to this VList
     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped
     * @param type Type of this list item, can be ListType.None
     */
    VList.prototype.appendItem = function (node, type) {
        var nodeTag = (0, getTagOfNode_1.default)(node);
        // Change DIV tag to SPAN. Otherwise we cannot create new list item by Enter key in Safari
        if (nodeTag == 'DIV') {
            node = (0, changeElementTag_1.default)(node, 'LI');
        }
        else if (nodeTag != 'LI') {
            node = (0, wrap_1.default)(node, 'LI');
        }
        this.items.push(type == 0 /* None */ ? new VListItem_1.default(node) : new VListItem_1.default(node, type));
    };
    /**
     * Merge the given VList into current VList.
     * - All list items will be removed from the given VList and added into this list.
     * - The root node of the given VList will be removed from DOM tree
     * - If there are orphan items in the given VList, they will be merged into the last item
     *   of this list if any.
     * @param list The vList to merge from
     */
    VList.prototype.mergeVList = function (list) {
        var _this = this;
        var _a;
        if (list && list != this) {
            list.items.forEach(function (item) { return _this.items.push(item); });
            list.items.splice(0, list.items.length);
            (_a = list.rootList.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(list.rootList);
        }
    };
    VList.prototype.findListItems = function (start, end, callback) {
        if (this.items.length == 0) {
            return [];
        }
        var listStartPos = new Position_1.default(this.items[0].getNode(), 0 /* Begin */);
        var listEndPos = new Position_1.default(this.items[this.items.length - 1].getNode(), -1 /* End */);
        var startIndex = listStartPos.isAfter(start) ? 0 : -1;
        var endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);
        this.items.forEach(function (item, index) {
            startIndex = item.contains(start.node) ? index : startIndex;
            endIndex = item.contains(end.node) ? index : endIndex;
        });
        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;
        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;
        var result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];
        if (callback) {
            result.forEach(callback);
        }
        return result;
    };
    VList.prototype.populateItems = function (list, listTypes) {
        var _this = this;
        if (listTypes === void 0) { listTypes = []; }
        var type = (0, getListTypeFromNode_1.default)(list);
        var items = (0, toArray_1.default)(list.childNodes);
        items.forEach(function (item) {
            var newListTypes = __spreadArray(__spreadArray([], listTypes, true), [type], false);
            if ((0, getListTypeFromNode_1.isListElement)(item)) {
                _this.populateItems(item, newListTypes);
            }
            else if (item.nodeType != 3 /* Text */ || item.nodeValue.trim() != '') {
                _this.items.push(new (VListItem_1.default.bind.apply(VListItem_1.default, __spreadArray([void 0, item], newListTypes, false)))());
            }
        });
    };
    return VList;
}());
exports.default = VList;
//Normalization
// Step 1: Move all non-LI direct children under list into LI
// e.g.
// From: <ul><li>line 1</li>line 2</ul>
// To:   <ul><li>line 1<div>line 2</div></li></ul>
function moveChildNodesToLi(list) {
    var currentItem = null;
    (0, toArray_1.default)(list.childNodes).forEach(function (child) {
        if ((0, getTagOfNode_1.default)(child) == 'LI') {
            currentItem = child;
        }
        else if ((0, getListTypeFromNode_1.isListElement)(child)) {
            currentItem = null;
        }
        else if (currentItem && !(0, isNodeEmpty_1.default)(child, true /*trimContent*/)) {
            currentItem.appendChild((0, isBlockElement_1.default)(child) ? child : (0, wrap_1.default)(child));
        }
    });
}
// Step 2: Move nested LI up to under list directly
// e.g.
// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>
// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>
function moveLiToList(li) {
    while (!(0, getListTypeFromNode_1.isListElement)(li.parentNode)) {
        (0, splitParentNode_1.default)(li, true /*splitBefore*/);
        var furtherNodes = (0, toArray_1.default)(li.parentNode.childNodes).slice(1);
        if (furtherNodes.length > 0) {
            if (!(0, isBlockElement_1.default)(furtherNodes[0])) {
                furtherNodes = [(0, wrap_1.default)(furtherNodes)];
            }
            furtherNodes.forEach(function (node) { return li.appendChild(node); });
        }
        (0, unwrap_1.default)(li.parentNode);
    }
}
function getStart(list) {
    return (0, safeInstanceOf_1.default)(list, 'HTMLOListElement') ? list.start : undefined;
}
//# sourceMappingURL=VList.js.map