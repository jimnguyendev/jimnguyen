"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = require("../utils/contains");
var getListTypeFromNode_1 = require("./getListTypeFromNode");
var getTagOfNode_1 = require("../utils/getTagOfNode");
var isBlockElement_1 = require("../utils/isBlockElement");
var moveChildNodes_1 = require("../utils/moveChildNodes");
var safeInstanceOf_1 = require("../utils/safeInstanceOf");
var setListItemStyle_1 = require("../utils/setListItemStyle");
var toArray_1 = require("../utils/toArray");
var unwrap_1 = require("../utils/unwrap");
var wrap_1 = require("../utils/wrap");
var orderListStyles = [null, 'lower-alpha', 'lower-roman'];
/**
 * !!! Never directly create instance of this class. It should be created within VList class !!!
 *
 * Represent a list item.
 *
 * A list item is normally wrapped using a LI tag. But this class is only a logical item,
 * it can be a LI tag, or another other type of node which means it is actually not a list item.
 * That can happen after we do "outdent" on a 1-level list item, then it becomes not a list item.
 */
var VListItem = /** @class */ (function () {
    /**
     * Construct a new instance of VListItem class
     * @param node The DOM node for this item
     * @param listTypes An array represents list types of all parent and current level.
     * Skip this parameter for a non-list item.
     */
    function VListItem(node) {
        var listTypes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            listTypes[_i - 1] = arguments[_i];
        }
        this.newListStart = undefined;
        if (!node) {
            throw new Error('node must not be null');
        }
        this.node = (0, safeInstanceOf_1.default)(node, 'HTMLLIElement')
            ? node
            : (0, wrap_1.default)(node, 4 /* BlockListItem */);
        var display = this.node.style.display;
        this.dummy = display != 'list-item' && display != '';
        // Always add a None list type in front of all other types to represent non-list scenario.
        this.listTypes = __spreadArray([0 /* None */], listTypes, true);
    }
    /**
     * Get type of current list item
     */
    VListItem.prototype.getListType = function () {
        return this.listTypes[this.listTypes.length - 1];
    };
    /**
     * Get the levels of this list item.
     */
    VListItem.prototype.getLevel = function () {
        return this.listTypes.length - 1;
    };
    /**
     * Get DOM node of this list item
     */
    VListItem.prototype.getNode = function () {
        return this.node;
    };
    /**
     * Get the Start Number of the new List
     */
    VListItem.prototype.getNewListStart = function () {
        return this.newListStart;
    };
    /**
     * Check if a given node is contained by this list item
     * @param node The node to check
     */
    VListItem.prototype.contains = function (node) {
        return (0, contains_1.default)(this.node, node, true /*treatSameNodeAsContain*/);
    };
    /**
     * Check if this item is a dummy item.
     * A dummy item is also represented by LI tag, but it won't render a bullet (for Unordered list) or a number (for Ordered list)
     * normally it has CSS style display set to a value other than "list-item"
     */
    VListItem.prototype.isDummy = function () {
        return this.dummy;
    };
    /**
     * @deprecated Always return false
     */
    VListItem.prototype.isOrphanItem = function () {
        return false;
    };
    /**
     * @deprecated
     */
    VListItem.prototype.canMerge = function (item) {
        if (!(item === null || item === void 0 ? void 0 : item.isOrphanItem()) || this.listTypes.length != item.listTypes.length) {
            return false;
        }
        return this.listTypes.every(function (type, index) { return item.listTypes[index] == type; });
    };
    /**
     * @deprecated
     */
    VListItem.prototype.mergeItems = function (items) {
        var _this = this;
        var nodesToWrap = (items === null || items === void 0 ? void 0 : items.map(function (item) { return item.node; })) || [];
        var targetNodes = wrapIfNotBlockNode(nodesToWrap, true /*checkFirst*/, false /*checkLast*/);
        targetNodes.forEach(function (node) { return _this.node.appendChild(node); });
    };
    /**
     * Indent this item
     * If this is not an list item, it will be no op
     */
    VListItem.prototype.indent = function () {
        var listType = this.getListType();
        if (listType != 0 /* None */) {
            this.listTypes.push(listType);
        }
    };
    /**
     * Outdent this item
     * If this item is already not an list item, it will be no op
     */
    VListItem.prototype.outdent = function () {
        if (this.listTypes.length > 1) {
            this.listTypes.pop();
        }
    };
    /**
     * Change list type of this item
     * @param targetType The target list type to change to
     */
    VListItem.prototype.changeListType = function (targetType) {
        if (targetType == 0 /* None */) {
            this.listTypes = [targetType];
        }
        else {
            this.outdent();
            this.listTypes.push(targetType);
        }
    };
    /**
     * Set whether the item is a dummy item
     * @param isDummy Whether the item is a dummy item
     */
    VListItem.prototype.setIsDummy = function (isDummy) {
        this.dummy = isDummy;
    };
    /**
     * Set the start Number of the new list
     * @param isDummy Whether the item is a dummy item
     */
    VListItem.prototype.setNewListStart = function (startNumber) {
        this.newListStart = startNumber;
    };
    /**
     * Write the change result back into DOM
     * @param listStack current stack of list elements
     * @param originalRoot Original list root element. It will be reused when write back if possible
     */
    VListItem.prototype.writeBack = function (listStack, originalRoot) {
        var nextLevel = 1;
        // 1. Determine list elements that we can reuse
        // e.g.:
        //    passed in listStack: Fragment > OL > UL > OL
        //    local listTypes:     null     > OL > UL > UL > OL
        //    then Fragment > OL > UL can be reused
        for (; nextLevel < listStack.length; nextLevel++) {
            if ((0, getListTypeFromNode_1.default)(listStack[nextLevel]) !== this.listTypes[nextLevel]) {
                listStack.splice(nextLevel);
                break;
            }
        }
        // 2. Add new list elements
        // e.g.:
        //    passed in listStack: Fragment > OL > UL
        //    local listTypes:     null     > OL > UL > UL > OL
        //    then we need to create a UL and a OL tag
        for (; nextLevel < this.listTypes.length; nextLevel++) {
            var newList = createListElement(listStack[0], this.listTypes[nextLevel], nextLevel, originalRoot);
            listStack[listStack.length - 1].appendChild(newList);
            listStack.push(newList);
        }
        // 3. Add current node into deepest list element
        listStack[listStack.length - 1].appendChild(this.node);
        this.node.style.display = this.dummy ? 'block' : null;
        // 4. Inherit styles of the child element to the li, so we are able to apply the styles to the ::marker
        if (this.listTypes.length > 1) {
            if (!(this.node.style.fontSize || this.node.style.color || this.node.style.fontFamily)) {
                var stylesToInherit = ['font-size', 'font-family', 'color'];
                (0, setListItemStyle_1.default)(this.node, stylesToInherit);
            }
        }
        // 5. If this is not a list item now, need to unwrap the LI node and do proper handling
        if (this.listTypes.length <= 1) {
            wrapIfNotBlockNode((0, getTagOfNode_1.default)(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node], true /*checkFirst*/, true /*checkLast*/);
        }
    };
    return VListItem;
}());
exports.default = VListItem;
function createListElement(newRoot, listType, nextLevel, originalRoot) {
    var doc = newRoot.ownerDocument;
    var result;
    // Try to reuse the existing root element
    // It can be reused when
    // 1. Current list item is level 1 (top level), AND
    // 2. Original root exists, AND
    // 3. They have the same list type AND
    // 4. The original root is not used yet
    if (nextLevel == 1 && originalRoot && listType == (0, getListTypeFromNode_1.default)(originalRoot)) {
        if ((0, contains_1.default)(newRoot, originalRoot)) {
            // If it is already used, let's clone one and remove ID to avoid duplicating ID
            result = originalRoot.cloneNode(false /*deep*/);
            result.removeAttribute('id');
        }
        else {
            // Remove all child nodes, they will be added back later when write back other items
            (0, moveChildNodes_1.default)(originalRoot);
            result = originalRoot;
        }
    }
    else {
        // Can't be reused, can't clone, let's create a new one
        result = doc.createElement(listType == 1 /* Ordered */ ? 'ol' : 'ul');
    }
    if (listType == 1 /* Ordered */ && nextLevel > 1) {
        result.style.listStyleType = orderListStyles[(nextLevel - 1) % orderListStyles.length];
    }
    return result;
}
function wrapIfNotBlockNode(nodes, checkFirst, checkLast) {
    if (nodes.length > 0 &&
        (!checkFirst || !(0, isBlockElement_1.default)(nodes[0])) &&
        (!checkLast || !(0, isBlockElement_1.default)(nodes[nodes.length]))) {
        nodes = [(0, wrap_1.default)(nodes)];
    }
    return nodes;
}
function getChildrenAndUnwrap(node) {
    var result = (0, toArray_1.default)(node.childNodes);
    (0, unwrap_1.default)(node);
    return result;
}
//# sourceMappingURL=VListItem.js.map