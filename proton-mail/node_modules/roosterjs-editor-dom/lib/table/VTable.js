"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var moveChildNodes_1 = require("../utils/moveChildNodes");
var normalizeRect_1 = require("../utils/normalizeRect");
var safeInstanceOf_1 = require("../utils/safeInstanceOf");
var toArray_1 = require("../utils/toArray");
/**
 * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells
 */
var VTable = /** @class */ (function () {
    /**
     * Create a new instance of VTable object using HTML TABLE or TD node
     * @param node The HTML Table or TD node
     */
    function VTable(node, normalizeSize) {
        var _this = this;
        this.trs = [];
        this.table = (0, safeInstanceOf_1.default)(node, 'HTMLTableElement') ? node : getTableFromTd(node);
        if (this.table) {
            var currentTd_1 = (0, safeInstanceOf_1.default)(node, 'HTMLTableElement') ? null : node;
            var trs = (0, toArray_1.default)(this.table.rows);
            this.cells = trs.map(function (row) { return []; });
            trs.forEach(function (tr, rowIndex) {
                _this.trs[rowIndex % 2] = tr;
                for (var sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {
                    // Skip the cells which already initialized
                    for (; _this.cells[rowIndex][targetCol]; targetCol++) { }
                    var td = tr.cells[sourceCol];
                    if (td == currentTd_1) {
                        _this.col = targetCol;
                        _this.row = rowIndex;
                    }
                    for (var colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {
                        for (var rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {
                            var hasTd = colSpan + rowSpan == 0;
                            var rect = td.getBoundingClientRect();
                            _this.cells[rowIndex + rowSpan][targetCol] = {
                                td: hasTd ? td : null,
                                spanLeft: colSpan > 0,
                                spanAbove: rowSpan > 0,
                                width: hasTd ? rect.width : undefined,
                                height: hasTd ? rect.height : undefined,
                            };
                        }
                    }
                }
            });
            if (normalizeSize) {
                this.normalizeSize();
            }
        }
    }
    /**
     * Write the virtual table back to DOM tree to represent the change of VTable
     */
    VTable.prototype.writeBack = function () {
        var _this = this;
        if (this.cells) {
            (0, moveChildNodes_1.default)(this.table);
            this.cells.forEach(function (row, r) {
                var tr = cloneNode(_this.trs[r % 2] || _this.trs[0]);
                _this.table.appendChild(tr);
                row.forEach(function (cell, c) {
                    if (cell.td) {
                        _this.recalculateSpans(r, c);
                        tr.appendChild(cell.td);
                    }
                });
            });
        }
        else if (this.table) {
            this.table.parentNode.removeChild(this.table);
        }
    };
    /**
     * Apply the given table format to this virtual table
     * @param format Table format to apply
     */
    VTable.prototype.applyFormat = function (format) {
        if (!format || !this.table) {
            return;
        }
        this.table.style.borderCollapse = 'collapse';
        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';
        if (this.trs[1]) {
            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';
        }
        this.cells.forEach(function (row) {
            return row
                .filter(function (cell) { return cell.td; })
                .forEach(function (cell) {
                cell.td.style.borderTop = getBorderStyle(format.topBorderColor);
                cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);
                cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);
                cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);
            });
        });
    };
    /**
     * Edit table with given operation.
     * @param operation Table operation
     */
    VTable.prototype.edit = function (operation) {
        var _this = this;
        if (!this.table) {
            return;
        }
        var currentRow = this.cells[this.row];
        var currentCell = currentRow[this.col];
        var style = currentCell.td.style;
        switch (operation) {
            case 0 /* InsertAbove */:
                this.cells.splice(this.row, 0, currentRow.map(cloneCell));
                break;
            case 1 /* InsertBelow */:
                var newRow_1 = this.row + this.countSpanAbove(this.row, this.col);
                this.cells.splice(newRow_1, 0, this.cells[newRow_1 - 1].map(function (cell, colIndex) {
                    var nextCell = _this.getCell(newRow_1, colIndex);
                    if (nextCell.spanAbove) {
                        return cloneCell(nextCell);
                    }
                    else if (cell.spanLeft) {
                        var newCell = cloneCell(cell);
                        newCell.spanAbove = false;
                        return newCell;
                    }
                    else {
                        return {
                            td: cloneNode(_this.getTd(_this.row, colIndex)),
                        };
                    }
                }));
                break;
            case 2 /* InsertLeft */:
                this.forEachCellOfCurrentColumn(function (cell, row) {
                    row.splice(_this.col, 0, cloneCell(cell));
                });
                break;
            case 3 /* InsertRight */:
                var newCol_1 = this.col + this.countSpanLeft(this.row, this.col);
                this.forEachCellOfColumn(newCol_1 - 1, function (cell, row, i) {
                    var nextCell = _this.getCell(i, newCol_1);
                    var newCell;
                    if (nextCell.spanLeft) {
                        newCell = cloneCell(nextCell);
                    }
                    else if (cell.spanAbove) {
                        newCell = cloneCell(cell);
                        newCell.spanLeft = false;
                    }
                    else {
                        newCell = {
                            td: cloneNode(_this.getTd(i, _this.col)),
                        };
                    }
                    row.splice(newCol_1, 0, newCell);
                });
                break;
            case 6 /* DeleteRow */:
                this.forEachCellOfCurrentRow(function (cell, i) {
                    var nextCell = _this.getCell(_this.row + 1, i);
                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {
                        nextCell.td = cell.td;
                    }
                });
                this.cells.splice(this.row, 1);
                break;
            case 5 /* DeleteColumn */:
                this.forEachCellOfCurrentColumn(function (cell, row, i) {
                    var nextCell = _this.getCell(i, _this.col + 1);
                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {
                        nextCell.td = cell.td;
                    }
                    row.splice(_this.col, 1);
                });
                break;
            case 7 /* MergeAbove */:
            case 8 /* MergeBelow */:
                var rowStep = operation == 7 /* MergeAbove */ ? -1 : 1;
                for (var rowIndex = this.row + rowStep; rowIndex >= 0 && rowIndex < this.cells.length; rowIndex += rowStep) {
                    var cell = this.getCell(rowIndex, this.col);
                    if (cell.td && !cell.spanAbove) {
                        var aboveCell = rowIndex < this.row ? cell : currentCell;
                        var belowCell = rowIndex < this.row ? currentCell : cell;
                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {
                            (0, moveChildNodes_1.default)(aboveCell.td, belowCell.td, true /*keepExistingChildren*/);
                            belowCell.td = null;
                            belowCell.spanAbove = true;
                        }
                        break;
                    }
                }
                break;
            case 9 /* MergeLeft */:
            case 10 /* MergeRight */:
                var colStep = operation == 9 /* MergeLeft */ ? -1 : 1;
                for (var colIndex = this.col + colStep; colIndex >= 0 && colIndex < this.cells[this.row].length; colIndex += colStep) {
                    var cell = this.getCell(this.row, colIndex);
                    if (cell.td && !cell.spanLeft) {
                        var leftCell = colIndex < this.col ? cell : currentCell;
                        var rightCell = colIndex < this.col ? currentCell : cell;
                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {
                            (0, moveChildNodes_1.default)(leftCell.td, rightCell.td, true /*keepExistingChildren*/);
                            rightCell.td = null;
                            rightCell.spanLeft = true;
                        }
                        break;
                    }
                }
                break;
            case 4 /* DeleteTable */:
                this.cells = null;
                break;
            case 12 /* SplitVertically */:
                if (currentCell.td.rowSpan > 1) {
                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);
                }
                else {
                    var splitRow = currentRow.map(function (cell) {
                        return {
                            td: cell == currentCell ? cloneNode(cell.td) : null,
                            spanAbove: cell != currentCell,
                            spanLeft: cell.spanLeft,
                        };
                    });
                    this.cells.splice(this.row + 1, 0, splitRow);
                }
                break;
            case 11 /* SplitHorizontally */:
                if (currentCell.td.colSpan > 1) {
                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);
                }
                else {
                    this.forEachCellOfCurrentColumn(function (cell, row) {
                        row.splice(_this.col + 1, 0, {
                            td: row == currentRow ? cloneNode(cell.td) : null,
                            spanAbove: cell.spanAbove,
                            spanLeft: row != currentRow,
                        });
                    });
                }
                break;
            case 13 /* AlignCenter */:
                this.table.style.marginLeft = 'auto';
                this.table.style.marginRight = 'auto';
                break;
            case 14 /* AlignLeft */:
                this.table.style.marginLeft = '';
                this.table.style.marginRight = 'auto';
                break;
            case 15 /* AlignRight */:
                this.table.style.marginLeft = 'auto';
                this.table.style.marginRight = '';
                break;
            case 17 /* AlignCellCenter */:
                style.textAlign = 'center';
                break;
            case 16 /* AlignCellLeft */:
                style.textAlign = 'left';
                break;
            case 18 /* AlignCellRight */:
                style.textAlign = 'right';
                break;
            case 19 /* AlignCellTop */:
                style.verticalAlign = 'top';
                break;
            case 20 /* AlignCellMiddle */:
                style.verticalAlign = 'middle';
                break;
            case 21 /* AlignCellBottom */:
                style.verticalAlign = 'bottom';
                break;
        }
    };
    /**
     * Loop each cell of current column and invoke a callback function
     * @param callback The callback function to invoke
     */
    VTable.prototype.forEachCellOfCurrentColumn = function (callback) {
        this.forEachCellOfColumn(this.col, callback);
    };
    /**
     * Loop each table cell and get all the cells that share the same border from one side
     * The result is an array of table cell elements
     * @param borderPos The position of the border
     * @param getLeftCells Get left-hand-side or right-hand-side cells of the border
     *
     * Example, consider having a 3 by 4 table as below with merged and split cells
     *
     *     | 1 | 4 | 7 | 8 |
     *     |   5   |   9   |
     *     |   3   |   10  |
     *
     *  input => borderPos: the 3rd border, getLeftCells: true
     *  output => [4, 5, 3]
     *
     *  input => borderPos: the 3rd border, getLeftCells: false
     *  output => [7, 9, 10]
     *
     *  input => borderPos: the 2nd border, getLeftCells: true
     *  output => [1]
     *
     *  input => borderPos: the 2nd border, getLeftCells: false
     *  output => [4]
     */
    VTable.prototype.getCellsWithBorder = function (borderPos, getLeftCells) {
        var cells = [];
        for (var i = 0; i < this.cells.length; i++) {
            for (var j = 0; j < this.cells[i].length; j++) {
                var cell = this.getCell(i, j);
                if (cell.td) {
                    var cellRect = (0, normalizeRect_1.default)(cell.td.getBoundingClientRect());
                    var found = false;
                    if (getLeftCells) {
                        if (cellRect.right == borderPos) {
                            found = true;
                            cells.push(cell.td);
                        }
                        else if (found) {
                            break;
                        }
                    }
                    else {
                        if (cellRect.left == borderPos) {
                            found = true;
                            cells.push(cell.td);
                        }
                        else if (found) {
                            break;
                        }
                    }
                }
            }
        }
        return cells;
    };
    /**
     * Loop each cell of current row and invoke a callback function
     * @param callback The callback function to invoke
     */
    VTable.prototype.forEachCellOfCurrentRow = function (callback) {
        this.forEachCellOfRow(this.row, callback);
    };
    /**
     * Get a table cell using its row and column index. This function will always return an object
     * even if the given indexes don't exist in table.
     * @param row The row index
     * @param col The column index
     */
    VTable.prototype.getCell = function (row, col) {
        return (this.cells && this.cells[row] && this.cells[row][col]) || {};
    };
    /**
     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell
     */
    VTable.prototype.getCurrentTd = function () {
        return this.getTd(this.row, this.col);
    };
    VTable.prototype.getTd = function (row, col) {
        if (this.cells) {
            row = Math.min(this.cells.length - 1, row);
            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;
            if (!isNaN(row) && !isNaN(col)) {
                while (row >= 0 && col >= 0) {
                    var cell = this.getCell(row, col);
                    if (cell.td) {
                        return cell.td;
                    }
                    else if (cell.spanLeft) {
                        col--;
                    }
                    else if (cell.spanAbove) {
                        row--;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        return null;
    };
    VTable.prototype.forEachCellOfColumn = function (col, callback) {
        for (var i = 0; i < this.cells.length; i++) {
            callback(this.getCell(i, col), this.cells[i], i);
        }
    };
    VTable.prototype.forEachCellOfRow = function (row, callback) {
        for (var i = 0; i < this.cells[row].length; i++) {
            callback(this.getCell(row, i), i);
        }
    };
    VTable.prototype.recalculateSpans = function (row, col) {
        var td = this.getCell(row, col).td;
        if (td) {
            td.colSpan = this.countSpanLeft(row, col);
            td.rowSpan = this.countSpanAbove(row, col);
            if (td.colSpan == 1) {
                td.removeAttribute('colSpan');
            }
            if (td.rowSpan == 1) {
                td.removeAttribute('rowSpan');
            }
        }
    };
    VTable.prototype.countSpanLeft = function (row, col) {
        var result = 1;
        for (var i = col + 1; i < this.cells[row].length; i++) {
            var cell = this.getCell(row, i);
            if (cell.td || !cell.spanLeft) {
                break;
            }
            result++;
        }
        return result;
    };
    VTable.prototype.countSpanAbove = function (row, col) {
        var result = 1;
        for (var i = row + 1; i < this.cells.length; i++) {
            var cell = this.getCell(i, col);
            if (cell.td || !cell.spanAbove) {
                break;
            }
            result++;
        }
        return result;
    };
    VTable.prototype.normalizeEmptyTableCells = function () {
        for (var i = 0, row = void 0; (row = this.table.rows[i]); i++) {
            for (var j = 0, cell = void 0; (cell = row.cells[j]); j++) {
                if (cell) {
                    if (!cell.innerHTML || !cell.innerHTML.trim()) {
                        cell.appendChild(document.createElement('br'));
                    }
                }
            }
        }
    };
    /* normalize width/height for each cell in the table */
    VTable.prototype.normalizeTableCellSize = function () {
        // remove width/height for each row
        for (var i = 0, row = void 0; (row = this.table.rows[i]); i++) {
            row.removeAttribute('width');
            row.style.width = null;
            row.removeAttribute('height');
            row.style.height = null;
        }
        // set width/height for each cell
        for (var i = 0; i < this.cells.length; i++) {
            for (var j = 0; j < this.cells[i].length; j++) {
                var cell = this.cells[i][j];
                if (cell) {
                    setHTMLElementSizeInPx(cell.td, cell.width, cell.height);
                }
            }
        }
    };
    VTable.prototype.normalizeSize = function () {
        this.normalizeEmptyTableCells();
        this.normalizeTableCellSize();
        setHTMLElementSizeInPx(this.table); // Make sure table width/height is fixed to avoid shifting effect
    };
    return VTable;
}());
exports.default = VTable;
function setHTMLElementSizeInPx(element, newWidth, newHeight) {
    if (!!element) {
        element.removeAttribute('width');
        element.removeAttribute('height');
        element.style.boxSizing = 'border-box';
        var rect = element.getBoundingClientRect();
        element.style.width = (newWidth !== undefined ? newWidth : rect.width) + "px";
        element.style.height = (newHeight !== undefined ? newHeight : rect.height) + "px";
    }
}
function getTableFromTd(td) {
    var result = td;
    for (; result && result.tagName != 'TABLE'; result = result.parentElement) { }
    return result;
}
function getBorderStyle(style) {
    return 'solid 1px ' + (style || 'transparent');
}
/**
 * Clone a table cell
 * @param cell The cell to clone
 */
function cloneCell(cell) {
    return {
        td: cloneNode(cell.td),
        spanAbove: cell.spanAbove,
        spanLeft: cell.spanLeft,
    };
}
/**
 * Clone a node without its children.
 * @param node The node to clone
 */
function cloneNode(node) {
    var newNode = node ? node.cloneNode(false /*deep*/) : null;
    if ((0, safeInstanceOf_1.default)(newNode, 'HTMLTableCellElement')) {
        newNode.removeAttribute('id');
        if (!newNode.firstChild) {
            newNode.appendChild(node.ownerDocument.createElement('br'));
        }
    }
    return newNode;
}
//# sourceMappingURL=VTable.js.map