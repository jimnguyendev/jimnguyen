"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var getTagOfNode_1 = require("./getTagOfNode");
var Position_1 = require("../selection/Position");
var splitTextNode_1 = require("./splitTextNode");
var wrap_1 = require("./wrap");
var getLeafSibling_1 = require("./getLeafSibling");
var splitParentNode_1 = require("./splitParentNode");
var STYLET_AGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');
/**
 * Apply style using a styler function to the given container node in the given range
 * @param container The container node to apply style to
 * @param styler The styler function
 * @param from From position
 * @param to To position
 */
function applyTextStyle(container, styler, from, to) {
    if (from === void 0) { from = new Position_1.default(container, 0 /* Begin */).normalize(); }
    if (to === void 0) { to = new Position_1.default(container, -1 /* End */).normalize(); }
    var formatNodes = [];
    while (from && to && to.isAfter(from)) {
        var formatNode = from.node;
        var parentTag = (0, getTagOfNode_1.default)(formatNode.parentNode);
        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node
        var nextNode = (0, getLeafSibling_1.getNextLeafSibling)(container, formatNode);
        if (formatNode.nodeType == 3 /* Text */ && ['TR', 'TABLE'].indexOf(parentTag) < 0) {
            if (formatNode == to.node && !to.isAtEnd) {
                formatNode = (0, splitTextNode_1.default)(formatNode, to.offset, true /*returnFirstPart*/);
            }
            if (from.offset > 0) {
                formatNode = (0, splitTextNode_1.default)(formatNode, from.offset, false /*returnFirstPart*/);
            }
            formatNodes.push(formatNode);
        }
        from = nextNode && new Position_1.default(nextNode, 0 /* Begin */);
    }
    if (formatNodes.length > 0) {
        if (formatNodes.every(function (node) { return node.parentNode == formatNodes[0].parentNode; })) {
            var newNode_1 = formatNodes.shift();
            formatNodes.forEach(function (node) {
                newNode_1.nodeValue += node.nodeValue;
                node.parentNode.removeChild(node);
            });
            formatNodes = [newNode_1];
        }
        formatNodes.forEach(function (node) {
            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them
            // So that the inner style tag such as U, STRIKE can inherit the style we added
            while ((0, getTagOfNode_1.default)(node) != 'SPAN' &&
                STYLET_AGS.indexOf((0, getTagOfNode_1.default)(node.parentNode)) >= 0) {
                callStylerWithInnerNode(node, styler);
                node = (0, splitParentNode_1.splitBalancedNodeRange)(node);
            }
            if ((0, getTagOfNode_1.default)(node) != 'SPAN') {
                callStylerWithInnerNode(node, styler);
                node = (0, wrap_1.default)(node, 'SPAN');
            }
            styler(node);
        });
    }
}
exports.default = applyTextStyle;
function callStylerWithInnerNode(node, styler) {
    if (node && node.nodeType == 1 /* Element */) {
        styler(node, true /*isInnerNode*/);
    }
}
//# sourceMappingURL=applyTextStyle.js.map