"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var changeElementTag_1 = require("./changeElementTag");
var contains_1 = require("./contains");
var createRange_1 = require("../selection/createRange");
var findClosestElementAncestor_1 = require("./findClosestElementAncestor");
var getBlockElementAtNode_1 = require("../blockElements/getBlockElementAtNode");
var getTagOfNode_1 = require("./getTagOfNode");
var isNodeEmpty_1 = require("./isNodeEmpty");
var isPositionAtBeginningOf_1 = require("../selection/isPositionAtBeginningOf");
var isVoidHtmlElement_1 = require("./isVoidHtmlElement");
var LinkInlineElement_1 = require("../inlineElements/LinkInlineElement");
var Position_1 = require("../selection/Position");
var PositionContentSearcher_1 = require("../contentTraverser/PositionContentSearcher");
var queryElements_1 = require("./queryElements");
var splitTextNode_1 = require("./splitTextNode");
var toArray_1 = require("./toArray");
var unwrap_1 = require("./unwrap");
var VTable_1 = require("../table/VTable");
var wrap_1 = require("./wrap");
var splitParentNode_1 = require("./splitParentNode");
var adjustSteps = [
    adjustInsertPositionForHyperLink,
    adjustInsertPositionForStructuredNode,
    adjustInsertPositionForParagraph,
    adjustInsertPositionForVoidElement,
    adjustInsertPositionForMoveCursorOutOfALink,
];
/**
 * Adjust position for A tag don't be nested inside another A tag.
 */
function adjustInsertPositionForHyperLink(root, nodeToInsert, position, range) {
    var _a, _b;
    var blockElement = (0, getBlockElementAtNode_1.default)(root, position.node);
    if (blockElement) {
        // Find the first <A> tag within current block which covers current selection
        // If there are more than one nested, let's handle the first one only since that is not a common scenario.
        var anchor = (0, queryElements_1.default)(root, 'a[href]', null /*forEachCallback*/, 1 /* OnSelection */, (0, createRange_1.default)(position)).filter(function (a) { return blockElement.contains(a); })[0];
        // If this is about to insert node to an empty A tag, clear the A tag and reset position
        if (anchor && (0, isNodeEmpty_1.default)(anchor)) {
            position = new Position_1.default(anchor, -2 /* Before */);
            safeRemove(anchor);
            anchor = null;
        }
        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag
        // otherwise we will have nested A tags which is a wrong HTML structure
        if (anchor &&
            ((_a = nodeToInsert) === null || _a === void 0 ? void 0 : _a.querySelector) &&
            ((_b = nodeToInsert) === null || _b === void 0 ? void 0 : _b.querySelector('a[href]'))) {
            var normalizedPosition = position.normalize();
            var parentNode = normalizedPosition.node.parentNode;
            var nextNode = normalizedPosition.node.nodeType == 3 /* Text */
                ? (0, splitTextNode_1.default)(normalizedPosition.node, normalizedPosition.offset, false /*returnFirstPart*/)
                : normalizedPosition.isAtEnd
                    ? normalizedPosition.node.nextSibling
                    : normalizedPosition.node;
            var splitter = root.ownerDocument.createTextNode('');
            parentNode.insertBefore(splitter, nextNode);
            while ((0, contains_1.default)(anchor, splitter)) {
                splitter = (0, splitParentNode_1.splitBalancedNodeRange)(splitter);
            }
            position = new Position_1.default(splitter, -2 /* Before */);
            safeRemove(splitter);
        }
    }
    return position;
}
/**
 * Adjust position for a node don't be nested inside tags like BR, LI, TD.
 */
function adjustInsertPositionForStructuredNode(root, nodeToInsert, position, range) {
    var rootNodeToInsert = nodeToInsert;
    if (rootNodeToInsert.nodeType == 11 /* DocumentFragment */) {
        var rootNodes = (0, toArray_1.default)(rootNodeToInsert.childNodes).filter(function (n) { return (0, getTagOfNode_1.default)(n) != 'BR'; });
        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;
    }
    var tag = (0, getTagOfNode_1.default)(rootNodeToInsert);
    var hasBrNextToRoot = tag && (0, getTagOfNode_1.default)(rootNodeToInsert.nextSibling) == 'BR';
    var listItem = (0, findClosestElementAncestor_1.default)(position.node, root, 'LI');
    var listNode = listItem && (0, findClosestElementAncestor_1.default)(listItem, root, 'OL,UL');
    var tdNode = (0, findClosestElementAncestor_1.default)(position.node, root, 'TD,TH');
    var trNode = tdNode && (0, findClosestElementAncestor_1.default)(tdNode, root, 'TR');
    if (tag == 'LI') {
        tag = listNode ? (0, getTagOfNode_1.default)(listNode) : 'UL';
        rootNodeToInsert = (0, wrap_1.default)(rootNodeToInsert, tag);
    }
    if ((tag == 'OL' || tag == 'UL') && (0, getTagOfNode_1.default)(rootNodeToInsert.firstChild) == 'LI') {
        var shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;
        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {
            safeRemove(rootNodeToInsert.nextSibling);
        }
        if (shouldInsertListAsText) {
            (0, unwrap_1.default)(rootNodeToInsert.firstChild);
            (0, unwrap_1.default)(rootNodeToInsert);
        }
        else if ((0, getTagOfNode_1.default)(listNode) == tag) {
            (0, unwrap_1.default)(rootNodeToInsert);
            position = new Position_1.default(listItem, (0, isPositionAtBeginningOf_1.default)(position, listItem)
                ? -2 /* Before */
                : -3 /* After */);
        }
    }
    else if (tag == 'TABLE' && trNode) {
        // When inserting a table into a table, if these tables have the same column count, and
        // current position is at beginning of a row, then merge these two tables
        var newTable = new VTable_1.default(rootNodeToInsert);
        var currentTable = new VTable_1.default(tdNode);
        if (currentTable.col == 0 &&
            tdNode == currentTable.getCell(currentTable.row, 0).td &&
            newTable.cells[0] &&
            newTable.cells[0].length == currentTable.cells[0].length &&
            (0, isPositionAtBeginningOf_1.default)(position, tdNode)) {
            if ((0, getTagOfNode_1.default)(rootNodeToInsert.firstChild) == 'TBODY' &&
                !rootNodeToInsert.firstChild.nextSibling) {
                (0, unwrap_1.default)(rootNodeToInsert.firstChild);
            }
            (0, unwrap_1.default)(rootNodeToInsert);
            position = new Position_1.default(trNode, -3 /* After */);
        }
    }
    return position;
}
/**
 * Change P tag to DIV, when a new node when insert node.
 */
function adjustInsertPositionForParagraph(root, nodeToInsert, position, range) {
    if ((0, getTagOfNode_1.default)(position.node) == 'P') {
        // Insert into a P tag may cause issues when the inserted content contains any block element.
        // Change P tag to DIV to make sure it works well
        var pos = position.normalize();
        var div = (0, changeElementTag_1.default)(position.node, 'div');
        if (pos.node != div) {
            position = pos;
        }
    }
    return position;
}
/**
 * Adjust position for a node that can have children.
 */
function adjustInsertPositionForVoidElement(root, nodeToInsert, position, range) {
    if ((0, isVoidHtmlElement_1.default)(position.node)) {
        position = new Position_1.default(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */);
    }
    return position;
}
/**
 * Adjust the position cursor out of link when a new node is inserted.
 */
function adjustInsertPositionForMoveCursorOutOfALink(root, nodeToInsert, position, range) {
    if (range && range.collapsed) {
        var searcher = new PositionContentSearcher_1.default(root, Position_1.default.getStart(range));
        var inlineElementBefore = searcher.getInlineElementBefore();
        var inlineElementAfter = searcher.getInlineElementAfter();
        if (inlineElementBefore instanceof LinkInlineElement_1.default) {
            position = new Position_1.default(inlineElementBefore.getContainerNode(), -3 /* After */);
        }
        else if (inlineElementAfter instanceof LinkInlineElement_1.default) {
            position = new Position_1.default(inlineElementAfter.getContainerNode(), -2 /* Before */);
        }
    }
    return position;
}
/**
 *
 * @param root the contentDiv of the ditor
 * @param nodeToInsert the node to be inserted
 * @param position the position of the node to be inserted
 * @param range the range current or cached range of the editor
 * @returns the adjusted position of the inserted node
 */
function adjustInsertPositionBySteps(root, nodeToInsert, position, range) {
    adjustSteps.forEach(function (handler) {
        position = handler(root, nodeToInsert, position, range);
    });
    return position;
}
exports.default = adjustInsertPositionBySteps;
function safeRemove(node) {
    var _a;
    (_a = node === null || node === void 0 ? void 0 : node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
}
//# sourceMappingURL=adjustInsertPosition.js.map