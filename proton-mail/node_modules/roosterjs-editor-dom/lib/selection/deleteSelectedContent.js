"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var arrayPush_1 = require("../utils/arrayPush");
var collapseNodesInRegion_1 = require("../region/collapseNodesInRegion");
var getRegionsFromRange_1 = require("../region/getRegionsFromRange");
var getSelectionRangeInRegion_1 = require("../region/getSelectionRangeInRegion");
var mergeBlocksInRegion_1 = require("../region/mergeBlocksInRegion");
var Position_1 = require("./Position");
var queryElements_1 = require("../utils/queryElements");
var safeInstanceOf_1 = require("../utils/safeInstanceOf");
var splitTextNode_1 = require("../utils/splitTextNode");
/**
 * Delete selected content, and return the new position to select
 * @param core The EditorCore object.
 * @param range The range to delete
 */
function deleteSelectedContent(root, range) {
    var nodeBefore = null;
    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detect them from step 2
    // since table cells will fall in to different regions
    var nodesToDelete = (0, queryElements_1.default)(root, 'table,tr', null /*callback*/, 2 /* InSelection */, range);
    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.
    // We don't delete them directly here because delete node from one region may cause selection range
    // another region becomes invalid. So we delay the process of deletion.
    var regions = (0, getRegionsFromRange_1.default)(root, range, 0 /* Table */);
    var nodesPairToMerge = regions
        .map(function (region) {
        var regionRange = (0, getSelectionRangeInRegion_1.default)(region);
        if (!regionRange) {
            return null;
        }
        var startContainer = regionRange.startContainer, endContainer = regionRange.endContainer, startOffset = regionRange.startOffset, endOffset = regionRange.endOffset;
        // Make sure there are node before and after the merging point.
        // This is required by mergeBlocksInRegion API.
        // This may create some empty text node as anchor
        var _a = ensureBeforeAndAfter(endContainer, endOffset, false /*isStart*/), beforeEnd = _a[0], afterEnd = _a[1];
        var _b = ensureBeforeAndAfter(startContainer, startOffset, true /*isStart*/), beforeStart = _b[0], afterStart = _b[1];
        nodeBefore = nodeBefore || beforeStart;
        // Find out all nodes to be deleted
        var nodes = (0, collapseNodesInRegion_1.default)(region, [afterStart, beforeEnd]);
        (0, arrayPush_1.default)(nodesToDelete, nodes);
        return { region: region, beforeStart: beforeStart, afterEnd: afterEnd };
    })
        .filter(function (x) { return !!x; });
    // 3. Delete all nodes that we found
    nodesToDelete.forEach(function (node) { var _a; return (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node); });
    // 4. Merge lines for each region, so that after we don't see extra line breaks
    nodesPairToMerge.forEach(function (nodes) {
        return (0, mergeBlocksInRegion_1.default)(nodes.region, nodes.beforeStart, nodes.afterEnd);
    });
    return nodeBefore && new Position_1.default(nodeBefore, -1 /* End */);
}
exports.default = deleteSelectedContent;
function ensureBeforeAndAfter(node, offset, isStart) {
    var _a;
    if ((0, safeInstanceOf_1.default)(node, 'Text')) {
        var newNode = (0, splitTextNode_1.default)(node, offset, isStart);
        return isStart ? [newNode, node] : [node, newNode];
    }
    else {
        var nodeBefore = node.childNodes[offset - 1];
        var nodeAfter = node.childNodes[offset];
        // Condition 1: node child nodes
        // ("I" means cursor; "o" means a DOM node, "[ ]" means a parent node)
        // [ I ]
        // need to use parent node instead to convert to condition 2
        if (!nodeBefore && !nodeAfter) {
            if (isStart) {
                nodeAfter = node;
                nodeBefore = nodeAfter.previousSibling;
            }
            else {
                nodeBefore = node;
                nodeAfter = nodeBefore.nextSibling;
            }
        }
        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)
        // [ o I ]  or [ I o]
        // need to add empty text node to convert to condition 3
        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {
            var emptyNode = node.ownerDocument.createTextNode('');
            (_a = (nodeBefore || nodeAfter).parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(emptyNode, nodeAfter);
            if (nodeBefore) {
                nodeAfter = emptyNode;
            }
            else {
                nodeBefore = emptyNode;
            }
        }
        // Condition 3: Both nodeBefore and nodeAfter are not null
        // [o I o]
        // return the nodes
        return [nodeBefore, nodeAfter];
    }
}
//# sourceMappingURL=deleteSelectedContent.js.map